<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F2018%2F11%2F14%2FTypora%2F</url>
    <content type="text"><![CDATA[Typora快捷键无序列表1输入-之后输入空格 有序列表1输入数字+“.”之后输入空格 任务列表1-[空格]空格 文字 标题1ctrl+数字 表格1ctrl+t 生成目录1[TOC]按回车 选中一整行1ctrl+l 选中单词1ctrl+d 选中相同格式的文字1ctrl+e 跳转到文章开头1ctrl+home 跳转到文章结尾1ctrl+end 搜索1ctrl+f 替换1ctrl+h 引用1输入&gt;之后输入空格 代码块1ctrl+alt+f 加粗1ctrl+b 倾斜1ctrl+i 下划线1ctrl+u 删除线1alt+shift+5 插入图片1直接拖动到指定位置即可或者ctrl+shift+i 插入链接1ctrl+k 插入代码1```+语言 例如 ```js就是插入js代码]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2018%2F11%2F14%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker阿里云镜像地址：dev.aliyun.com 1 Docker安装与启动1.1 Docker的安装在linux操作系统中，执行以下命令进行安装 (1) yum 包更新到最新 1sudo yum update (2) 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 (3) 设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo (4) 安装docker ce是社区版本，ee是企业版（收费） 1sudo yum install docker-ce (5) 安装后查看docker版本 1docker -v 1.2 设置ustc的镜像ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 也可以设置阿里云的镜像，只需要修改daemon.json 123&#123; &quot;registry-mirrors&quot;: [&quot;此处为个人阿里云的镜像地址&quot;]&#125; 1.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker 1systemctl start docker 停止docker 1systemctl stop docker 重启docker 1systemctl restart docker 查看docker状态 1systemctl status docker 开机启动 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 2 常用命令2.1 镜像相关的命令2.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 2.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 2.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 2.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 2.2 容器相关命令2.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 2.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令 1docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 2.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 2.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 2.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 2.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID） 2.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 3 应用部署3.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 3.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 3.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 3.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 4 迁移与备份4.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 4.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 4.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 5 Dockerfile5.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境； 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 3、对于运维人员：在部署时，可以实现应用的无缝移植。 5.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 5.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 6 Docker私有仓库6.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 6.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js及ES6]]></title>
    <url>%2F2018%2F11%2F13%2Fnode-js%2F</url>
    <content type="text"><![CDATA[1 Node.js1.1 什么是Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 1.2 Node.js安装1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/ 2、选安装目录进行安装 默认即可 3.测试 在命令提示符下输入命令 1node -v 会显示当前node的版本 1.3 快速入门1.3.1 控制台输出我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件demo1.js,代码内容 123var a=1;var b=2;console.log(a+b); 我们在命令提示符下输入命令 1node demo1.js 1.3.2 使用函数创建文本文件demo2.js 12345var c=add(100,200);console.log(c);function add(a,b)&#123; return a+b;&#125; 命令提示符输入命令 1node demo2.js 运行后看到输出结果为300 1.3.3 模块化编程创建文本文件demo3_1.js 123exports.add=function(a,b)&#123; return a+b;&#125; 创建文本文件demo3_2.js 12var demo= require('./demo3_1');console.log(demo.add(400,600)); 我们在命令提示符下输入命令 1node demo3_2.js 结果为1000 1.3.4 创建web服务器创建文本文件demo4.js 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); http为node内置的web模块 我们在命令提示符下输入命令 1node demo4.js 服务启动后，我们打开浏览器，输入网址 http://localhost:8888/ 即可看到网页输出结果Hello World 心情是不是很激动呢？Ctrl+c 终止运行。 1.3.5 理解服务端渲染我们创建demo5.js ，将上边的例子写成循环的形式 1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" for(var i=0;i&lt;10;i++)&#123; response.write('Hello World\n'); &#125; response.end(''); &#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令启动服务 1node demo5.js 浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。 我们右键“查看源代码”发现，并没有我们写的for循环语句，而是直接的10条Hello World ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的JSP很是相似。 1.3.6 接收参数创建demo6.js 1234567891011var http = require('http');var url = require('url');http.createServer(function(request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(request.url, true).query; response.write("name:" + params.name); response.write("\n"); response.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令 1node demo6.js 在浏览器测试结果 2 包资源管理器NPM2.1 什么是NPMnpm全称Node Package Manager，他是node包管理和分发工具。其实我们可以把NPM理解为前端的Maven 我们通过npm 可以很方便地下载js库，管理前端工程. 最新版本的node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本 2.2 NPM命令2.2.1 初始化工程init命令是工程初始化命令。 建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化 1npm init 按照提示输入相关信息，如果是用默认值则直接回车即可。 name: 项目名称 version: 项目版本号 description: 项目描述 keywords: {Array}关键词，便于用户搜索到我们的项目 最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml 我们之后也可以根据需要进行修改。 2.2.2 本地安装install命令用于安装某个模块，如果我们想安装express模块（node的web框架），输出命令如下： 1npm install express 出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。 在该目录下已经出现了一个node_modules文件夹 和package-lock.json node_modules文件夹用于存放下载的js库（相当于maven的本地仓库） package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 我们再打开package.json文件，发现刚才下载的express已经添加到依赖列表中了. 关于版本号定义： 1234567指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 2.2.3 全局安装刚才我们使用的是本地安装，会将js库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。 如果你不知道你的全局目录在哪里，执行命令 1npm root -g 我的全局目录在 C:\Users\Administrator\AppData\Roaming\npm\node_modules 比如我们全局安装jquery, 输入以下命令 1npm install jquery -g 2.2.4 批量下载我们从网上下载某些代码，发现只有package.json,没有node_modules文件夹，这时我们需要通过命令重新下载这些js库. 进入目录（package.json所在的目录）输入命令 1npm install 此时，npm会自动下载package.json中依赖的js库. 2.2.5淘宝NPM镜像【建议使用】有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 输入命令，进行全局安装淘宝镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装后，我们可以使用以下命令来查看cnpm的版本 1cnpm -v 使用cnpm 1cnpm install 需要下载的js库 2.2.6 运行工程如果我们想运行某个工程，则使用run命令 如果package.json中定义的脚本如下 dev是开发阶段测试运行 build是构建编译工程 lint 是运行js代码检测 我们现在来试一下运行dev 1npm run dev 2.2.7 编译工程我们接下来，测试一个代码的编译.编译后我们就可以将工程部署到nginx中啦~ 编译后的代码会放在dist文件夹中，首先我们先删除dist文件夹中的文件,进入命令提示符输入命令 1npm run build 生成后我们会发现只有个静态页面，和一个static文件夹 这种工程我们称之为单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 这里其实是调用了webpack来实现打包的，关于webpack我们后续的章节进行介绍 3 Webpack3.1 什么是Webpack​ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 ​ 从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 接下来我们简单为大家介绍 Webpack 的安装与使用 3.2 Webpack安装全局安装 12npm install webpack -gnpm install webpack-cli -g 安装后查看版本号 1webpack -v 3.3 快速入门3.3.1 JS打包（1）创建src文件夹，创建bar.js 123exports.info=function(str)&#123; document.write(str);&#125; （2）src下创建logic.js 123exports.add=function(a,b)&#123; return a+b;&#125; （3）src下创建main.js 123var bar= require('./bar');var logic= require('./logic');bar.info( 'Hello world!'+ logic.add(100,200)); （4）创建配置文件webpack.config.js ，该文件与src处于同级目录 12345678var path = require("path");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;&#125;; 以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js （5）执行编译命令 1webpack 执行后查看bundle.js 会发现里面包含了上面两个js文件的内容 （7）创建index.html ,引用bundle.js 12345678&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试调用index.html，会发现有内容输出 3.3.2 CSS打包（1）安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css 1cnpm install style-loader css-loader --save-dev （2）修改webpack.config.js 12345678910111213141516var path = require("path");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125;; （3）在src文件夹创建css文件夹,css文件夹下创建css1 123body&#123; background:red;&#125; （4）修改main.js ，引入css1.css 1require(&apos;./css1.css&apos;); （5）重新运行webpack （6）运行index.html看看背景是不是变成红色啦？ 4 ES64.1 什么是ES6编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA（一个类似W3C的标准组织）参与进行标准化的语法规范。ECMAScript定义了： 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。 类型 – 布尔型、数字、字符串、对象等。 原型和继承 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。 ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。 ECMAScript标准的历史版本分别是1、2、3、5。 那么为什么没有第4版？其实，在过去确实曾计划发布提出巨量新特性的第4版，但最终却因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）。 ES4饱受争议，当标准委员会最终停止开发ES4时，其成员同意发布一个相对谦和的ES5版本，随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命名为“Harmony”，因此，ES5规范中包含这样两句话 ECMAScript是一门充满活力的语言，并在不断进化中。 未来版本的规范中将持续进行重要的技术改进 2009年发布的改进版本ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 4.2 Node.js中使用ES6ES6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成ES5 （1）babel转换配置,项目根目录添加.babelrc 文件 123&#123; "presets" : ['es2015']&#125; （2）安装es6转换模块 1cnpm install babel-preset-es2015 --save-dev （3）全局安装命令行工具 1cnpm install babel-cli -g （4）使用 1babel-node js文件名 4.3 语法新特性4.3.1 变量声明let【重要】我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是: 12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场： 我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码 12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125; &#125; 4.3.2 常量声明const 用于声明常量，看以下代码 12const name = 'lux'name = 'joe' //再次赋值此时会报错 4.3.3 模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 123456//es5 var name = 'lux'console.log('hello' + name )//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。 1234567// es5var msg = "Hi \man!"// es6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 4.3.4 函数默认参数ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 看例子代码 12345function action(num = 200) &#123; console.log(num)&#125;action() //200action(300) //300 4.3.5 箭头函数【重点】ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 1不需要function关键字来创建函数 2省略return关键字 3继承当前上下文的 this 关键字 看下面代码（ES6） 123(response,message) =&gt; &#123; .......&#125; 相当于ES5代码 123function(response,message)&#123; ......&#125; 4.3.6 对象初始化简写ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 以上代码可以简写为 123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; 4.3.7 解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下 1234567const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 4.3.8 Spread OperatorES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组 123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c" 4.3.9 import 和 export【重点】import导入模块、export导出模块 lib.js 123456789101112131415161718let fn0=function()&#123; console.log('fn0...');&#125;export &#123;fn0&#125;let dele=function()&#123; console.log('dele...');&#125;export &#123;dele&#125;// 还可以写成export default &#123; fn0()&#123; console.log('fn0...'); &#125;, dele()&#123; // .... &#125;&#125; demo9.js 1234567891011import &#123;fn0&#125; from './lib'import &#123;dele&#125; from './lib'fn0();// 还可以写成// 1.import * as jsApi from './lib.js' // 后缀可以省略jsApi.info()jsApi.dele()// 2.import jsApi from './lib.js' // 使用这种方式 ，必须要使用export default &#123;&#125; 导出 注意：node(v8.x)本身并不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容） 1babel-node demo9 4.3.10 Promise​ Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise. promise参考链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2018%2F11%2F13%2FVue%2F</url>
    <content type="text"><![CDATA[Vue1 vue简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。和AngularJS的语法非常的相似。 Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。 1.1 MVVM模式MVVM模式： M ： Model (数据) V ：View（视图）–静态页面 VM ：vue 的实例 1234567const vm = new Vue(&#123; // this ---》 当前的 VM的实例 el:"#id", // id任意即可 data:&#123; message:"hello..." &#125;&#125;) 2 Vue常用的指令2.1 插值表达式1&#123;&#123; message &#125;&#125; // 表达式内可以 写算术运算， 调用vue的方法， 但是不可以定义 js的变量等 2.2 v-onv-on:click , v-on:keydown 和原生js 一样的，vue给我们提供简写的方式 @click, 绑定事件的处理 2.3 v-text 和 v-html 和 v-bindv-text: 绑定的数据是文本 v-html: 显示带HTML代码的数据， 也可以显示存文本 v-bind: 强制绑定HTML标签的属性上， 简写： 如：v-bind:href=”url” ， 简写 :href=”url” 2.4 v-model绑定表单中得HTML的变量 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 2.5 v-forv-for： 循环遍历 ， 字符串数组， 遍历对象， 集合… 1v-for="(item, index) in list " :key="index" 2.6 v-if 和 v-show判断是否显示当前的变量的值， 如果条件成立，显示， 否则不显示 3 Vue生命周期 8个分为三大类： 初始化方法（四个）只会调用一次 更新显示（循环） 销毁VM实例 4 axios异步调用参考官网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
