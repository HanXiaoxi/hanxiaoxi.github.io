<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础总结]]></title>
    <url>%2F2018%2F11%2F30%2Fjava%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java基础1.java中的“==”和equals()方法的区别 12(1) ==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址.(2) equals方法不能作用于基本数据类型的变量如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；可以对equals方法重写，比较的是所指向的对象的内容。 2.为什么不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法 123java中规定，abstract只能修饰类和方法修饰的类为抽象类，抽象类不能实例化，需要子类继承并实现抽象方法。修饰的方法为抽象方法，只有声明方法，并没有实现，需要子类继承实现 3.abstract class 和 interface的区别 1234567891011121314151617181920抽象类： 含有abstract修饰符的class即为抽象类 abstract 类不能创建的实例对象。 含有abstract方法的类必须定义为abstract class abstract class类中的方法不必是抽象的。 abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子 类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。接口（interface）： 接口中的所有方法都必须是抽象的 接口中的方法定义默认为public abstract类型 接口中的成员变量类型默认为public static final。语法区别：1.抽象类可以有构造方法，接口中不能有构造方法。2.抽象类中可以有普通成员变量，接口中没有普通成员变量3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。5. 抽象类中可以包含静态方法，接口中不能包含静态方法6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。7. 一个类可以实现多个接口，但只能继承一个抽象类。 4.对面向对象特征多态的理解 123456父类引用指向子类对象，可以调用子类重写的父类方法基于继承实现的多态：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。 如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。 基于接口的多态：在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。 5.封装继承多态 1封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题,提高程序的可扩展性. 6.String类的常用方法有哪些 ？ 1234567891011121314151617String(byte[] bytes, String charsetName) 通过指定的字符编码解码直接数组构造新的string对象charAt(int index)concat(String str) contains(CharSequence s) endsWith(String suffix) equals(Object anObject) getBytes(Charset charset) indexOf(int ch) lastIndexOf(int ch) length() replace(char oldChar, char newChar) split(String regex) substring(int beginIndex) toString() trim() toUpperCase() toLowerCase() 7.java语句 String str = new String(“hello”)；执行时，创建了几个对象？ 122个对象一个是在常量池创建一个“hello”的对象，另一个是new String()创建的对象 8.对序列化的理解 1序列化是为了保存在内存中的各种对象的状态，经过流的传输，还可以把保存的对象状态再读出来。 9.什么是反射 12345反射机制指的是程序在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。反射获取对象的三种方式： 1) 对象.getClass()方法 2) Class.forName(String className) 3) 类名.class 10.什么是动态代理 1利用Java的反射技术(Java Reflection)，在运行时创建一个实现某些给定接口的新类（也称“动态代理类”）及其实例（对象）。代理的是接口(Interfaces)，不是类(Class)，更不是抽象类。 11.什么是多线程、线程的启动方式、线程安全问题如何解决 123456789101112131415161718多线程：指的是一个程序（进程）运行时产生了不止一个线程。程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程 调用start方法启动线程安全问题如何解决 如何判断线程是否安全？ (1)是否 存在多线程环境 (2)在多线程环境下，是否有共享的变量 (3)在多线程环境下是否多共享变量进行写操作 只有三个条件同时满足，才会出现线程安全的问题 解决： 只要破坏上面的三个条件之一即可 对于2，不建议在成员的位置上定义变量 对于3，加锁（同步代码块） 12.解释protected 12345protected是java的权限修饰符，被protected修饰后，只有当前类、同包下的类以及子类能访问 public:所有位置的对象都能访问 protected：只有当前类、同包下的类、子类能访问 default(不写)：只有当前类和同包下的类能访问 private：只有当前类能访问 13.StringBuilder和StringBuffer区别 1StringBuilder是线程不安全的，而StringBuffer是线程安全的,运行速度上，StringBuilder较快 14.cglib和jdk的核心 123456789静态代理：简单，代理模式，是动态代理的理论基础。常见使用在代理模式jdk动态代理：需要有顶层接口才能使用，但是在只有顶层接口的时候也可以使用，常见是mybatis的mapper文件是代理。使用反射完成。使用了动态生成字节码技术。cglib动态代理：可以直接代理类，使用字节码技术，不能对 final类进行继承。使用了动态生成字节码技术。JDK代理是不需要第三方库支持，只需要JDK环境就可以进行代理，使用条件: 1）实现InvocationHandler 2）使用Proxy.newProxyInstance产生代理对象 3）被代理的对象必须要实现接口CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承但是针对接口编程的环境下推荐使用JDK的代理； 15.乐观锁和悲观锁 12345678悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 16.垃圾回收机制 12345678910111213141516171819202122232425262728293031323334353637381)如何确定某个对象是需要被回收？ 在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式称为引用计数法。 以下三类对象在jvm中作为GC roots，来判断一个对象是否可以被回收 (通常来说我们只要知道虚拟机栈和静态引用就够了) 1、虚拟机栈(JVM stack)中引用的对象(准确的说是虚拟机栈中的栈帧(frames)) 。我们知道，每个方法执行的时候，jvm都会创建一个相应的栈帧(栈帧中包括操作数栈、局部变量表、运行时常量池的引用)，栈帧中包含这在方法内部使用的所有对象的引用(当然还有其他的基本类型数据)，当方法执行完后，该栈帧会从虚拟机栈中弹出，这样一来，临时创建的对象的引用也就不存在了，或者说没有任何gc roots指向这些临时对象，这些对象在下一次GC时便会被回收掉 2、方法区中类静态属性引用的对象 。静态属性是该类型(class)的属性，不单独属于任何实例，因此该属性自然会作为gc roots。只要这个class存在，该引用指向的对象也会一直存在。class 也是会被回收的，在面后说明 3、本地方法栈(Native Stack)引用的对象 下面介绍下关于软引用（softReference）和弱引用（weakReference）的对象垃圾回收对他们做的处理 String str = new String(&quot;hello&quot;);//A SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;java&quot;));//B WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String(&quot;world&quot;));//C 上面的几个对象中回收情况如下，B在内存不足的情况下会将String对象判定为可回收对象，C无论什么情况下String对象都会被判定为可回收对象。也就是说软引用会在内存溢出（OOM）的时候回收，而弱引用无论什么情况都会在下一轮回收的时候回收掉。 一般jvm会对这些对象回收 1、显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象。 2、局部引用所指向的对象。 3、上面说的弱引用（weakReference）。 2)典型的垃圾收集算法，是怎么回收对象的？ 1、Mark-Sweep（标记-清除）算法 2、Copying（复制）算法 3、Mark-Compact（标记-整理）算法 4、Generational Collection（分代收集）算法3)典型的垃圾收集器有哪些？1.Serial/Serial Old Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。2.ParNew ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。3.Parallel Scavenge Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。4.Parallel Old Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。5.CMS CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。6.G1 G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群]]></title>
    <url>%2F2018%2F11%2F28%2F%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[集群1.zookeeper1.1 注册中心宕机，会不会产生影响会，根据情况而定是否产生影响开发环境：会产生影响，不会对原有的方法产生影响，只会对当前新添加的方法产生影响生产环境：只要是这个方法被调用了，并且不会对当前的方法修改，不会产生影响 1.2 zookeeper的选举机制1.serverId越大，胜出的概率越大2.要求超出半数以上的节点同意某一个节点才可以3.只要是当前集群中有leader，则之后就不选举 建议：集群中的节点，至少是三台|超过半数以上的节点宕机，整个zookeeper的服务都不可用 2.RedisCluster集群把redis数据拆分为若干块，放在不同的服务器中存储 无中心节点每个节点都是集群的主入口 redis集群中内置了16384（2^14）个哈希槽， 投票容错机制 ping-pong机制:尽可能的以最快的方式检测当前节点是否故障 投票容错机制：超过一半的节点认为当前节点宕机，这个机器必定宕机。 官方建议奇数台，方便投票，至少需要3台，但是每个节点都需要一个从节点。（主写从读，从节点上没有分配槽）。 fastDFS]]></content>
      <categories>
        <category>集群</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[javaEE1. spring 对象关系映射ORMORM：对象关系映射 它通过现实ORM规范，完成面向对象的编程语言到关系数据库的映射。它可以把关系型数据库封装成对象，解决面向对象编程语言与底层关系数据库不协调的问题。它是面向对象编程言语与关系数据库之间的桥梁。 ORM映射基本规则12345671. 类与表相对应 2. 类的属性（成员变量）与表的字段相对应 3. 类的实例与表中具体的一条记录相对应 4. 一个类可以对应多个表，一个表也可以对应多个类 5. 数据库中的表可以没有主键，但是类的实例中必须设置主键字段 6. 数据库中表与表之间的关系（如外键）映射成为对象之间的关系 7. 对象中属性（成员变量）的个数和名称可以和表中定义的字段个数和名称不一样 2.Spring Bean 实例化方式 调用构造器创建Bean 123第一种方式：使用默认无参构造函数&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;&lt;bean id="accountService" class="com.han.service.impl.AccountServiceImpl"/&gt; 调用静态工厂方法创建Bean 1234567891011121314/*** 模拟一个静态工厂，创建业务层实现类*/public class StaticFactory &#123;public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是:使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器id 属性：指定 bean 的 id，用于从容器中获取class 属性：指定静态工厂的全限定类名factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id="accountService" class="com.han.factory.StaticFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 调用实例工厂方法创建Bean 123456789101112131415/*** 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法*/public class InstanceFactory &#123;public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是：先把工厂的创建交给 spring 来管理。然后在使用工厂的 bean 来调用里面的方法factory-bean 属性：用于指定实例工厂 bean 的 id。factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id="instancFactory" class="com.han.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instancFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; Bean对象的作用范围123456* singleton :默认值，单例的.* prototype :多例的.* request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.* session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.* global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. Bean生命周期123456789101112单例对象：scope=&quot;singleton&quot; 一个应用只有一个对象的实例。它的作用范围就是整个引用。 生命周期： 对象出生：当应用加载，创建容器时，对象就被创建了。 对象活着：只要容器在，对象一直活着。 对象死亡：当应用卸载，销毁容器时，对象就被销毁了。多例对象：scope=&quot;prototype&quot;每次访问对象时，都会重新创建对象实例。 生命周期： 对象出生：当使用对象时，创建新的对象实例。 对象活着：只要对象在使用中，就一直活着。 对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 控制反转（IOC）与依赖注入（DI）控制反转（Inversion of Control），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入，还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC和DI的区别123(1) IOC:控制反转，把对象创建交给spring来管理(2) DI:依赖注入，向类里面的属性设置值(3) 关系：依赖注入不能单独存在，需要在IOC基础之上完成操作 构造器注入 1234567891011121314&lt;!--使用构造函数的方式，给 service 中的属性传值&lt;constructor-arg/&gt;标签属性 index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 =======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============value:它能赋的值是基本数据类型和 String 类型ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt;&lt;bean id="accountService" class="com.han.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value=" 张三 "&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; set方法注入 1234567891011&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式 property属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;property name="name" value="test"&gt;&lt;/property&gt;&lt;property name="age" value="21"&gt;&lt;/property&gt;&lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; Spring 中的 AOPJoinpoint( 连接点):​ 所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):​ 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):​ 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。​ 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):​ 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):​ 代理的目标对象。Weaving( 织入):​ 是指把增强应用到目标对象来创建新的代理对象的过程。​ spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:​ 一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):​ 是切入点和通知（引介）的结合。 3.solr创建索引库的方式4.异常处理参考全局异常 5.Dubboxdobbox消息传递使用的是zookeeper dubbox优点：降低耦合度，可以搭集群，增加访问数量dubbox缺点：传递存在风险 6.MyBatis的延迟加载与缓存开启 Mybatis 的延迟加载策略在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 1234567&lt;!-- 开启延迟加载的支持 --&gt;&lt;settings&gt; &lt;!--开启mybatis全局支持延迟加载， 可以使用fetchType属性来控制对应的方法是否延迟加载，覆盖该方法的加载方式--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!--将积极加载设置为延迟加载 mybatis3.4.1后默认就是延迟加载，不设置也是可以的--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; mybatis开启懒加载，只要设置 lazyLoadingEnable属性为true来开启全局延迟加载，fetchType属性可以控制某个指定的方法实现立即加载或延迟加载。 mybatis的一级缓存mybatis默认是存在一级缓存的，一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 清空缓存的方式 1231. SqlSession 的修改，添加，删除，commit()，close()等方法时2. 调用sqlSession.clearCache()3. 设置statement配置中的flushCache=&apos;true&apos; 属性 Mybatis的二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 二级缓存的开启与关闭第一步：在 SqlMapConfig.xml 文件开启二级缓存 12345&lt;settings&gt;&lt;!-- 开启二级缓存的支持 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 第二步：配置相关的 Mapper 映射文件 1234&lt;mapper namespace="com.han.dao.user"&gt;&lt;!-- 开启二级缓存的支持 --&gt;&lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; 第三步：配置 statement 上面的 useCache 属性 1234567&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt;将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 7.springMVC执行流程 客户端发送request请求，请求被发送到前端控制器DispatcherServlet，前端控制器请求查找Handler，找到处理器映射器HandlerMapping,handlerMapping根据请求的url找到对应的controller和方法方法，并返回给前端控制器，前端控制器会请求处理器适配器执行controller中的方法，返回modelAndView给前端控制器，前端控制器请求视图解析器解析，跳转到视图，对视图进行渲染并将处理的结果返回给用户。 springMVC的设计模式：适配器模式（处理器适配器） 8.HashMap 123hashMap的默认长度为2^4 = 16map的最大允许长度为2^30 ， integer的最大长度为2^31-1当map存储到12条数据时，map会自动扩容，增长的长度为原来长度的2的幂次方 hashMap的put方法初始化table hash算法是根据大量的数据演练得出的，利用了泊松分布，使得key均匀的分布在每个链表上，这样查询速度快 h &amp; (length-1)是保证了数组下标永远小于16，避免了数组越界问题 添加entry 扩容 添加数据 HashMap的get方法 线程123456789101112如何判断线程是否安全是否 存在多线程环境在多线程环境下，是否有共享的变量在多线程环境下是否多共享变量进行写操作三个条件同时满足，才会出现线程安全的问题如何解决？只要破坏上面的三个条件之一即可对于2，不建议在成员的位置上定义变量对于3，加锁（同步代码块）生产者消费者问题 --&gt;等待唤醒机制]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemark页面静态化]]></title>
    <url>%2F2018%2F11%2F20%2Ffreemarker%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Freemarker页面静态化freemarker的核心指令1. list指令12345678&lt;#list stus as stu&gt; &lt;tr&gt; &lt;td&gt;$&#123;stu_index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.mondy&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; 2. 遍历Map数据123456789101112131415方式一： 输出stu1的学生信息：&lt;br/&gt;姓名：$&#123;stuMap[&apos;stu1&apos;].name&#125;&lt;br/&gt;年龄：$&#123;stuMap[&apos;stu1&apos;].age&#125;&lt;br/&gt;方式二： 输出stu1的学生信息：&lt;br/&gt;姓名：$&#123;stuMap.stu1.name&#125;&lt;br/&gt;年龄：$&#123;stuMap.stu1.age&#125;&lt;br/&gt;方式三：&lt;#list stuMap?keys as k&gt;&lt;tr&gt; &lt;td&gt;$&#123;k_index + 1&#125;&lt;/td&gt; &lt;td&gt;$&#123;stuMap[k].name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stuMap[k].age&#125;&lt;/td&gt; &lt;td &gt;$&#123;stuMap[k].mondy&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/#list&gt; 3. if指令1&lt;#if stu.name ==&apos;小明&apos;&gt;style=&quot;background:red;&quot;&lt;/#if&gt;&gt;$&#123;stu.name&#125; 4. 运算符1、算数运算符 FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , % 2、逻辑运算符 逻辑运算符有如下几个: 逻辑与:&amp;&amp; 逻辑或:|| 逻辑非:! 逻辑运算符只能作用于布尔值,否则将产生错误 3、比较运算符 表达式中支持的比较运算符有如下几个: ​ 1) =或者==:判断两个值是否相等. ​ 2) !=:判断两个值是否不等. ​ 3) &gt;或者gt:判断左边值是否大于右边值 ​ 4) &gt;=或者gte:判断左边值是否大于等于右边值 ​ 5) &lt;或者lt:判断左边值是否小于右边值 ​ 6) &lt;=或者lte:判断左边值是否小于等于右边值注意: =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替&gt;会有更好的效果,因为 FreeMarker会把&gt;解释成FTL标签的结束字符,当然,也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt; 5. 空值处理1、判断某变量是否存在使用 “??” 用法为:variable??,如果该变量存在,返回true,否则返回false例：为防止stus为空报错可以加上判断如下： 12345 &lt;#if stus??&gt; &lt;#list stus as stu&gt; ...... &lt;/#list&gt; &lt;/#if&gt; 2、缺失变量默认值使用 “!” 使用!要以指定一个默认值，当变量为空时显示默认值。例： ${name!’’}表示如果name为空显示空字符串。如果是嵌套对象则建议使用（）括起来。例： ${(stu.bestFriend.name)!’’}表示，如果stu或bestFriend或name为空默认显示空字符串。注：!’’后面的空引号可以不写 6. 内建函数内建函数语法格式： 变量+?+函数名称1、和到某个集合的大小${集合名?size}2、日期格式化 1234显示年月日: $&#123;today?date&#125;显示时分秒：$&#123;today?time&#125; 显示日期+时间：$&#123;today?datetime&#125; &lt;br&gt; 自定义格式化： $&#123;today?string(&quot;yyyy年MM月&quot;)&#125; 3、内建函数cmap.put(“point”, 102920122);point是数字型，使用${point}会显示这个数字的值，不并每三位使用逗号分隔。如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出${point?c}4、将json字符串转成对象一个例子：其中用到了 assign标签，assign的作用是定义一个变量 123&lt;#assign text=&quot;&#123;&apos;bank&apos;:&apos;工商银行&apos;,&apos;account&apos;:&apos;10101920201920212&apos;&#125;&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重点笔记]]></title>
    <url>%2F2018%2F11%2F20%2F%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[VUE页面之间传递参数 通过在路由上添加key/value串（?传参）使用this.$route.query来取参。 例如： /router?id=123 可以通过this.$router.query.id获取参数id的值 通过将参数作为路由的一部分（restful风格）进行传参使用this.$route.params来获取 例如： 定义的路由为 /router/:id，请求/router/123时可以通过this.$router.params.id来获取，这种情况下使用this.$router.query.id是获取不到的]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局异常处理]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理如下代码 12345678910111213 //添加页面 public CmsPageResult add(CmsPage cmsPage)&#123;//校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1==null)&#123; cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,cmsPage); return cmsPageResult; &#125; return new CmsPageResult(CommonCode.FAIL,null); &#125; 1、上边的代码只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。 2、service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加try/catch，代码冗余严重且不易维护。 解决方案： 1、在Service方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成功信息。 2、在统一异常处理类中去捕获异常，无需controller捕获异常，向用户返回统一规范的响应信息。 1234567891011121314151617181920//添加页面public CmsPageResult add(CmsPage cmsPage)&#123; //校验cmsPage是否为空 if(cmsPage == null)&#123; //抛出异常，非法请求 //... &#125; //根据页面名称查询（页面名称已在mongodb创建了唯一索引） CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); //校验页面是否存在，已存在则抛出异常 if(cmsPage1 !=null)&#123; //抛出异常，已存在相同的页面名称 //... &#125; cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 CmsPage save = cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,save); return cmsPageResult;&#125; 1、在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 2、统一由异常捕获类捕获异常，并进行处理 3、捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 4、捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为99999错误代码并响应给用户。 5、将错误代码及错误信息以Json格式响应给用户。 自定义异常：主要是处理和业务相关的异常 不可预知的异常：主要是处理和业务无关的运行时异常 自定义异常类继承RuntimeException，对代码没有侵入性 统一异常捕获类，在类上加上@ControllerAdvice注解 声明一个方法，加上@ExceptionHandler注解，参数中如果没有写具体的异常，那么默认会拦截所有的异常。如果需要指定拦截的异常，那么需要给出拦截类的class。 springboot日志日志：开发环境设置level为DEBUG，生产环境设置为ERROR。 springboot中集成了日志记录功能，只需要将日志的配置文件logback-spring.xml（必须是这个文件名）放在resource目录下即可。 在异常类中定义 1private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class); 例如 1234567891011121314@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class); //捕获 CustomException异常 @ExceptionHandler(CustomException.class) @ResponseBody public ResponseResult customException(CustomException e) &#123; LOGGER.error("catch exception : &#123;&#125;\r\nexception: ",e.getMessage(), e);//注意，error中的&#123;&#125;一定要写，否则，无法记录日志。 ResultCode resultCode = e.getResultCode(); ResponseResult responseResult = new ResponseResult(resultCode); return responseResult; &#125;&#125; 普通的springMVC全局异常（项目有且只有一个全局异常类） 编写全局异常类GlobalExceptionResolver并实现HandlerExceptionResolver，并重写resolveException方法. 在springmvc的配置文件中引入bean 1&lt;bean class="com.han.springmvc.exception.GlobalExceptionResolver"/&gt;]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>全局异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[前后端分离实现1 Api请求及响应规范为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。 1、get 请求时，采用key/value格式请求，SpringMVC可采用基本类型的变量接收，也可以采用对象接收。 2、Post请求时，可以提交form表单数据（application/x-www-form-urlencoded）和Json数据（Content-Type=application/json），文件等多部件类型（multipart/form-data）三种数据格式，SpringMVC接收Json数据使用@RequestBody注解解析请求的json数据。 3、响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。 4、响应结果统一格式为json。 2 Api定义约束Api定义使用SpringMVC来完成，由于此接口后期将作为微服务远程调用使用，在定义接口时有如下限制： 1、@PathVariable 统一指定参数名称，如：@PathVariable(“id”)2、@RequestParam统一指定参数名称，如：@RequestParam（”id”）]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F2018%2F11%2F14%2FTypora%2F</url>
    <content type="text"><![CDATA[Typora快捷键无序列表1输入-之后输入空格 有序列表1输入数字+“.”之后输入空格 任务列表1-[空格]空格 文字 标题1ctrl+数字 表格1ctrl+t 生成目录1[TOC]按回车 选中一整行1ctrl+l 选中单词1ctrl+d 选中相同格式的文字1ctrl+e 跳转到文章开头1ctrl+home 跳转到文章结尾1ctrl+end 搜索1ctrl+f 替换1ctrl+h 引用1输入&gt;之后输入空格 代码块1ctrl+alt+f 加粗1ctrl+b 倾斜1ctrl+i 下划线1ctrl+u 删除线1alt+shift+5 插入图片1直接拖动到指定位置即可或者ctrl+shift+i 插入链接1ctrl+k 插入代码1```+语言 例如 ```js就是插入js代码]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2018%2F11%2F14%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker阿里云镜像地址：dev.aliyun.com 1 Docker安装与启动1.1 Docker的安装在linux操作系统中，执行以下命令进行安装 (1) yum 包更新到最新 1sudo yum update (2) 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 (3) 设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo (4) 安装docker ce是社区版本，ee是企业版（收费） 1sudo yum install docker-ce (5) 安装后查看docker版本 1docker -v 1.2 设置ustc的镜像ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 也可以设置阿里云的镜像，只需要修改daemon.json 123&#123; &quot;registry-mirrors&quot;: [&quot;此处为个人阿里云的镜像地址&quot;]&#125; 1.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker 1systemctl start docker 停止docker 1systemctl stop docker 重启docker 1systemctl restart docker 查看docker状态 1systemctl status docker 开机启动 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 2 常用命令2.1 镜像相关的命令2.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 2.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 2.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 2.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 2.2 容器相关命令2.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 2.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令 1docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 2.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 2.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 2.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 2.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID） 2.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 3 应用部署3.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 3.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 3.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 3.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 4 迁移与备份4.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 4.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 4.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 5 Dockerfile5.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境； 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 3、对于运维人员：在部署时，可以实现应用的无缝移植。 5.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 5.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 6 Docker私有仓库6.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 6.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js及ES6]]></title>
    <url>%2F2018%2F11%2F13%2Fnode-js%2F</url>
    <content type="text"><![CDATA[1 Node.js1.1 什么是Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 1.2 Node.js安装1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/ 2、选安装目录进行安装 默认即可 3.测试 在命令提示符下输入命令 1node -v 会显示当前node的版本 1.3 快速入门1.3.1 控制台输出我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件demo1.js,代码内容 123var a=1;var b=2;console.log(a+b); 我们在命令提示符下输入命令 1node demo1.js 1.3.2 使用函数创建文本文件demo2.js 12345var c=add(100,200);console.log(c);function add(a,b)&#123; return a+b;&#125; 命令提示符输入命令 1node demo2.js 运行后看到输出结果为300 1.3.3 模块化编程创建文本文件demo3_1.js 123exports.add=function(a,b)&#123; return a+b;&#125; 创建文本文件demo3_2.js 12var demo= require('./demo3_1');console.log(demo.add(400,600)); 我们在命令提示符下输入命令 1node demo3_2.js 结果为1000 1.3.4 创建web服务器创建文本文件demo4.js 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); http为node内置的web模块 我们在命令提示符下输入命令 1node demo4.js 服务启动后，我们打开浏览器，输入网址 http://localhost:8888/ 即可看到网页输出结果Hello World 心情是不是很激动呢？Ctrl+c 终止运行。 1.3.5 理解服务端渲染我们创建demo5.js ，将上边的例子写成循环的形式 1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" for(var i=0;i&lt;10;i++)&#123; response.write('Hello World\n'); &#125; response.end(''); &#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令启动服务 1node demo5.js 浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。 我们右键“查看源代码”发现，并没有我们写的for循环语句，而是直接的10条Hello World ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的JSP很是相似。 1.3.6 接收参数创建demo6.js 1234567891011var http = require('http');var url = require('url');http.createServer(function(request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(request.url, true).query; response.write("name:" + params.name); response.write("\n"); response.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令 1node demo6.js 在浏览器测试结果 2 包资源管理器NPM2.1 什么是NPMnpm全称Node Package Manager，他是node包管理和分发工具。其实我们可以把NPM理解为前端的Maven 我们通过npm 可以很方便地下载js库，管理前端工程. 最新版本的node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本 2.2 NPM命令2.2.1 初始化工程init命令是工程初始化命令。 建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化 1npm init 按照提示输入相关信息，如果是用默认值则直接回车即可。 name: 项目名称 version: 项目版本号 description: 项目描述 keywords: {Array}关键词，便于用户搜索到我们的项目 最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml 我们之后也可以根据需要进行修改。 2.2.2 本地安装install命令用于安装某个模块，如果我们想安装express模块（node的web框架），输出命令如下： 1npm install express 出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。 在该目录下已经出现了一个node_modules文件夹 和package-lock.json node_modules文件夹用于存放下载的js库（相当于maven的本地仓库） package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 我们再打开package.json文件，发现刚才下载的express已经添加到依赖列表中了. 关于版本号定义： 1234567指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 2.2.3 全局安装刚才我们使用的是本地安装，会将js库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。 如果你不知道你的全局目录在哪里，执行命令 1npm root -g 我的全局目录在 C:\Users\Administrator\AppData\Roaming\npm\node_modules 比如我们全局安装jquery, 输入以下命令 1npm install jquery -g 2.2.4 批量下载我们从网上下载某些代码，发现只有package.json,没有node_modules文件夹，这时我们需要通过命令重新下载这些js库. 进入目录（package.json所在的目录）输入命令 1npm install 此时，npm会自动下载package.json中依赖的js库. 2.2.5淘宝NPM镜像【建议使用】有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 输入命令，进行全局安装淘宝镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装后，我们可以使用以下命令来查看cnpm的版本 1cnpm -v 使用cnpm 1cnpm install 需要下载的js库 2.2.6 运行工程如果我们想运行某个工程，则使用run命令 如果package.json中定义的脚本如下 dev是开发阶段测试运行 build是构建编译工程 lint 是运行js代码检测 我们现在来试一下运行dev 1npm run dev 2.2.7 编译工程我们接下来，测试一个代码的编译.编译后我们就可以将工程部署到nginx中啦~ 编译后的代码会放在dist文件夹中，首先我们先删除dist文件夹中的文件,进入命令提示符输入命令 1npm run build 生成后我们会发现只有个静态页面，和一个static文件夹 这种工程我们称之为单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 这里其实是调用了webpack来实现打包的，关于webpack我们后续的章节进行介绍 3 Webpack3.1 什么是Webpack​ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 ​ 从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 接下来我们简单为大家介绍 Webpack 的安装与使用 3.2 Webpack安装全局安装 12npm install webpack -gnpm install webpack-cli -g 安装后查看版本号 1webpack -v 3.3 快速入门3.3.1 JS打包（1）创建src文件夹，创建bar.js 123exports.info=function(str)&#123; document.write(str);&#125; （2）src下创建logic.js 123exports.add=function(a,b)&#123; return a+b;&#125; （3）src下创建main.js 123var bar= require('./bar');var logic= require('./logic');bar.info( 'Hello world!'+ logic.add(100,200)); （4）创建配置文件webpack.config.js ，该文件与src处于同级目录 12345678var path = require("path");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;&#125;; 以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js （5）执行编译命令 1webpack 执行后查看bundle.js 会发现里面包含了上面两个js文件的内容 （7）创建index.html ,引用bundle.js 12345678&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试调用index.html，会发现有内容输出 3.3.2 CSS打包（1）安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css 1cnpm install style-loader css-loader --save-dev （2）修改webpack.config.js 12345678910111213141516var path = require("path");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125;; （3）在src文件夹创建css文件夹,css文件夹下创建css1 123body&#123; background:red;&#125; （4）修改main.js ，引入css1.css 1require(&apos;./css1.css&apos;); （5）重新运行webpack （6）运行index.html看看背景是不是变成红色啦？ 3.4 webpack-dev-serverwebpack-dev-server开发服务器，它的功能可以实现热加载 并且自动刷新浏览器。 3.4.1安装配置1、安装webpack-dev-server 1）创建一个新的程序目录 这里我们创建webpacktest02目录，并在目录下创建src目录、dist目录。 将main.js、module01.js、vue.min.js拷贝到src目录。 2）使用 webpack-dev-server需要安装webpack、 webpack-dev-server和 html-webpack-plugin三个包。 cnpm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 –save-dev 安装完成，会发现程序目录出现一个package.json文件，此文件中记录了程序的依赖。 2、配置webpack-dev-server 在package.json中配置script 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 5008&quot; &#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1，如果对外发布则填写公网ip地址 package.json的文件内容如下： 12345678910&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 5008&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot; &#125;&#125; devDependencies：开发人员在开发过程中所需要的依赖。 scripts：可执行的命令 3.4.2 配置webpack.config.jswebpack.config.js是webpack的配置文件。在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置html-webpack-plugin插件。 html-webpack-plugin的作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件。 1、配置模板文件 将原来的vue_02.html作为模板文件，为了和内存中的index.html文件名区别，注意将vue_02.html中的script标签去掉，内容如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js入门程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot; target=&quot;_blank&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt;= &lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;计算加&quot; v-on:click=&quot;add&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;计算减&quot; v-on:click=&quot;subtraction&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、配置 html-webpack-plugin 在webpack.config.js中配置html-webpack-plugin插件 123456789101112131415var htmlwp = require(&apos;html-webpack-plugin&apos;);module.exports=&#123; entry:&apos;./src/main.js&apos;, //指定打包的入口文件 output:&#123; path : __dirname+&apos;/dist&apos;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename:&apos;build.js&apos; //输出文件 &#125;, plugins:[ new htmlwp(&#123; title: &apos;首页&apos;, //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: &apos;index.html&apos;, //webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部，才能实现自动刷新功能 template: &apos;vue_02.html&apos; //根据index1.html这个模板来生成(这个文件请程序员自己生成) &#125;) ] &#125; 3.4.3 启动启动文件： 1、进入 webpacktest02目录，执行npm run dev 2、使用webstorm，右键package.json文件，选择“Show npm Scripts” 双击 dev。 注意：dev就是在package.json中配置的webpack dev server命令。 发现启动成功自动打开浏览器。 修改src中的任意文件内容，自动加载并刷新浏览器。 3.5 webpack debug调试使用了webpack之后就不能采用传统js的调试方法在chrome中打断点。 webpack将多个源文件打包成一个文件，并且文件的内容产生了很大的变化，webpack提供devtool进行调试，devtool是基于sourcemap的方式，在调试时会生成一个map文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了sourcemap就可以在调试时看到源代码。 配置如下： 1、在webpack.config.js中配置： 1devtool: &apos;eval-source-map&apos;, webpack.config.js部分内容如下： 123456789var htmlwp = require(&apos;html-webpack-plugin&apos;);module.exports=&#123; entry:&apos;./src/main.js&apos;, //指定打包的入口文件 output:&#123; path : __dirname+&apos;/dist&apos;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename:&apos;build.js&apos; //输出文件 &#125;, devtool: &apos;eval-source-map&apos;, ...... 2、在js中跟踪代码的位置上添加debugger 一个例子： 在add方法中添加debugger 12345// 定义add函数function add(x, y) &#123; debugger return x + y&#125; 启动应用，刷新页面跟踪代码： 点击“计算” 即进入debugger代码位置，此时可以使用chrome进行调试了。 4 ES64.1 什么是ES6编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA（一个类似W3C的标准组织）参与进行标准化的语法规范。ECMAScript定义了： 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。 类型 – 布尔型、数字、字符串、对象等。 原型和继承 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。 ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。 ECMAScript标准的历史版本分别是1、2、3、5。 那么为什么没有第4版？其实，在过去确实曾计划发布提出巨量新特性的第4版，但最终却因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）。 ES4饱受争议，当标准委员会最终停止开发ES4时，其成员同意发布一个相对谦和的ES5版本，随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命名为“Harmony”，因此，ES5规范中包含这样两句话 ECMAScript是一门充满活力的语言，并在不断进化中。 未来版本的规范中将持续进行重要的技术改进 2009年发布的改进版本ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 4.2 Node.js中使用ES6ES6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成ES5 （1）babel转换配置,项目根目录添加.babelrc 文件 123&#123; "presets" : ['es2015']&#125; （2）安装es6转换模块 1cnpm install babel-preset-es2015 --save-dev （3）全局安装命令行工具 1cnpm install babel-cli -g （4）使用 1babel-node js文件名 4.3 语法新特性4.3.1 变量声明let【重要】我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是: 12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场： 我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码 12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125; &#125; 4.3.2 常量声明const 用于声明常量，看以下代码 12const name = 'lux'name = 'joe' //再次赋值此时会报错 4.3.3 模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 123456//es5 var name = 'lux'console.log('hello' + name )//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。 1234567// es5var msg = "Hi \man!"// es6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 4.3.4 函数默认参数ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 看例子代码 12345function action(num = 200) &#123; console.log(num)&#125;action() //200action(300) //300 4.3.5 箭头函数【重点】ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 1不需要function关键字来创建函数 2省略return关键字 3继承当前上下文的 this 关键字 看下面代码（ES6） 123(response,message) =&gt; &#123; .......&#125; 相当于ES5代码 123function(response,message)&#123; ......&#125; 4.3.6 对象初始化简写ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 以上代码可以简写为 123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; 4.3.7 解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下 1234567const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 4.3.8 Spread OperatorES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组 123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c" 4.3.9 import 和 export【重点】import导入模块、export导出模块 lib.js 123456789101112131415161718let fn0=function()&#123; console.log('fn0...');&#125;export &#123;fn0&#125;let dele=function()&#123; console.log('dele...');&#125;export &#123;dele&#125;// 还可以写成export default &#123; fn0()&#123; console.log('fn0...'); &#125;, dele()&#123; // .... &#125;&#125; demo9.js 1234567891011import &#123;fn0&#125; from './lib'import &#123;dele&#125; from './lib'fn0();// 还可以写成// 1.import * as jsApi from './lib.js' // 后缀可以省略jsApi.info()jsApi.dele()// 2.import jsApi from './lib.js' // 使用这种方式 ，必须要使用export default &#123;&#125; 导出 注意：node(v8.x)本身并不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容） 1babel-node demo9 4.3.10 Promise​ Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise. promise参考链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2018%2F11%2F13%2FVue%2F</url>
    <content type="text"><![CDATA[Vue1 vue简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。和AngularJS的语法非常的相似。 Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。 1.1 MVVM模式MVVM模式： M ： Model (数据) V ：View（视图）–静态页面 VM ：vue 的实例 1234567const vm = new Vue(&#123; // this ---》 当前的 VM的实例 el:"#id", // id任意即可 data:&#123; message:"hello..." &#125;&#125;) 2 Vue常用的指令2.1 插值表达式1&#123;&#123; message &#125;&#125; // 表达式内可以 写算术运算， 调用vue的方法， 但是不可以定义 js的变量等 2.2 v-onv-on:click , v-on:keydown 和原生js 一样的，vue给我们提供简写的方式 @click, 绑定事件的处理 2.3 v-text 和 v-html 和 v-bindv-text: 绑定的数据是文本 v-html: 显示带HTML代码的数据， 也可以显示存文本 v-bind: 强制绑定HTML标签的属性上， 简写： 如：v-bind:href=”url” ， 简写 :href=”url” 2.4 v-model绑定表单中得HTML的变量 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 2.5 v-forv-for： 循环遍历 ， 字符串数组， 遍历对象， 集合… 1v-for="(item, index) in list " :key="index" 2.6 v-if 和 v-show判断是否显示当前的变量的值， 如果条件成立，显示， 否则不显示 3 Vue生命周期 通常使用最多的是created和mounted两个钩子： ​ created：vue实例已创建但是DOM元素还没有渲染生成。 ​ mounted：DOM元素渲染生成完成后调用。 8个分为三大类： 初始化方法（四个）只会调用一次 更新显示（循环） 销毁VM实例 4 axios异步调用参考官网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
